"""MCP Session Service using Redis for session persistence.

This service manages MCP SSE sessions in Redis to enable:
1. Session persistence across backend restarts
2. Graceful session rehydration - old sessions are accepted after restart
3. Session TTL (default 24 hours) to prevent stale sessions
4. No manual Cursor toggle required after backend restart

Architecture:
- Session state is stored in Redis with a 24-hour TTL
- Session ID is generated by MCP SDK, we just track it
- Backend restart → sessions persist → Cursor reconnects seamlessly
"""
import json
import time
from typing import Optional, Dict, Any
from datetime import datetime, timedelta
from src.services.cache_service import get_redis_client
import logging

logger = logging.getLogger(__name__)

# Session TTL: 24 hours (in seconds)
SESSION_TTL = 86400  # 24 * 60 * 60


class MCPSessionService:
    """Service for managing MCP sessions in Redis."""
    
    @staticmethod
    def _normalize_uuid(uuid_str: str) -> str:
        """Normalize UUID string (add dashes if missing).
        
        MCP SDK may send UUIDs without dashes, but we store them with dashes.
        This ensures we can find sessions regardless of format.
        
        Examples:
            "8ada66e38d364b2fa5235698f01bb1de" -> "8ada66e3-8d36-4b2f-a523-5698f01bb1de"
            "8ada66e3-8d36-4b2f-a523-5698f01bb1de" -> "8ada66e3-8d36-4b2f-a523-5698f01bb1de"
        """
        # Remove all dashes first
        clean = uuid_str.replace("-", "")
        
        # If it's 32 hex characters, format as UUID
        if len(clean) == 32 and all(c in '0123456789abcdefABCDEF' for c in clean):
            return f"{clean[:8]}-{clean[8:12]}-{clean[12:16]}-{clean[16:20]}-{clean[20:]}"
        
        # Return as-is if not a valid UUID format
        return uuid_str
    
    @staticmethod
    def _get_session_key(connection_id: str) -> str:
        """Get Redis key for session."""
        # Normalize UUID before creating key
        normalized_id = MCPSessionService._normalize_uuid(connection_id)
        return f"mcp:session:{normalized_id}"
    
    @staticmethod
    def _get_session_id_mapping_key(session_id: str) -> str:
        """Get Redis key for session_id -> connection_id mapping."""
        return f"mcp:session_id_map:{session_id}"
    
    @staticmethod
    def create_session(connection_id: str, metadata: Optional[Dict[str, Any]] = None) -> bool:
        """Create or update MCP session in Redis.
        
        Args:
            connection_id: Unique connection identifier (from client or generated)
            metadata: Optional session metadata (user_id, api_key_prefix, etc.)
            
        Returns:
            True if session was created/updated successfully
        """
        client = get_redis_client()
        if not client:
            logger.warning("Redis client not available, session will not persist")
            return False
        
        try:
            session_data = {
                "connection_id": connection_id,
                "created_at": datetime.utcnow().isoformat(),
                "last_activity_at": datetime.utcnow().isoformat(),
                "metadata": metadata or {},
            }
            
            key = MCPSessionService._get_session_key(connection_id)
            serialized = json.dumps(session_data)
            client.setex(key, SESSION_TTL, serialized)
            
                logger.info(f"MCP session created/updated: {connection_id[:8]}... (TTL: {SESSION_TTL}s)")
            return True
        except Exception as e:
            logger.error(f"Failed to create MCP session: {e}")
            return False
    
    @staticmethod
    def get_session(connection_id: str) -> Optional[Dict[str, Any]]:
        """Get MCP session from Redis.
        
        Args:
            connection_id: Connection identifier
            
        Returns:
            Session data if exists and not expired, None otherwise
        """
        client = get_redis_client()
        if not client:
            return None
        
        try:
            key = MCPSessionService._get_session_key(connection_id)
            value = client.get(key)
            
            if value:
                session_data = json.loads(value)
                logger.debug(f"MCP session found: {connection_id[:8]}...")
                return session_data
            
            logger.debug(f"MCP session not found: {connection_id[:8]}...")
            return None
        except Exception as e:
            logger.error(f"Failed to get MCP session: {e}")
            return None
    
    @staticmethod
    def update_session_activity(connection_id: str) -> bool:
        """Update session last activity timestamp.
        
        This extends the session TTL and records activity.
        
        Args:
            connection_id: Connection identifier
            
        Returns:
            True if updated successfully
        """
        client = get_redis_client()
        if not client:
            return False
        
        try:
            key = MCPSessionService._get_session_key(connection_id)
            value = client.get(key)
            
            if value:
                session_data = json.loads(value)
                session_data["last_activity_at"] = datetime.utcnow().isoformat()
                
                serialized = json.dumps(session_data)
                client.setex(key, SESSION_TTL, serialized)
                
                logger.debug(f"MCP session activity updated: {connection_id[:8]}...")
                return True
            
            logger.warning(f"MCP session not found for activity update: {connection_id[:8]}...")
            return False
        except Exception as e:
            logger.error(f"Failed to update MCP session activity: {e}")
            return False
    
    @staticmethod
    def delete_session(connection_id: str) -> bool:
        """Delete MCP session from Redis.
        
        Args:
            connection_id: Connection identifier
            
        Returns:
            True if deleted successfully
        """
        client = get_redis_client()
        if not client:
            return False
        
        try:
            key = MCPSessionService._get_session_key(connection_id)
            deleted = client.delete(key)
            
            if deleted:
                logger.info(f"MCP session deleted: {connection_id[:8]}...")
            else:
                logger.debug(f"MCP session not found for deletion: {connection_id[:8]}...")
            
            return bool(deleted)
        except Exception as e:
            logger.error(f"Failed to delete MCP session: {e}")
            return False
    
    @staticmethod
    def is_session_valid(connection_id: str) -> bool:
        """Check if session exists and is valid.
        
        Args:
            connection_id: Connection identifier
            
        Returns:
            True if session exists and is not expired
        """
        session = MCPSessionService.get_session(connection_id)
        return session is not None
    
    @staticmethod
    def save_session_id_mapping(session_id: str, connection_id: str) -> bool:
        """Save session_id -> connection_id mapping for reconnection.
        
        This enables the backend to find the original connection_id when
        the proxy reconnects with a session_id after backend restart.
        
        Args:
            session_id: MCP SDK generated session ID (from SSE endpoint event)
            connection_id: Our internal connection identifier
            
        Returns:
            True if mapping was saved successfully
        """
        client = get_redis_client()
        if not client:
            logger.warning("Redis client not available, session_id mapping will not persist")
            return False
        
        try:
            key = MCPSessionService._get_session_id_mapping_key(session_id)
            # Store just the connection_id as value
            client.setex(key, SESSION_TTL, connection_id)
            
            logger.info(f"Session ID mapping saved: {session_id[:8]}... → {connection_id[:8]}...")
            return True
        except Exception as e:
            logger.error(f"Failed to save session_id mapping: {e}")
            return False
    
    @staticmethod
    def get_connection_id_by_session_id(session_id: str) -> Optional[str]:
        """Get connection_id for a given session_id.
        
        This is used during reconnection to find the original connection_id
        so we can rehydrate the session instead of creating a new one.
        
        Args:
            session_id: MCP SDK generated session ID
            
        Returns:
            Connection ID if mapping exists, None otherwise
        """
        client = get_redis_client()
        if not client:
            return None
        
        try:
            key = MCPSessionService._get_session_id_mapping_key(session_id)
            connection_id = client.get(key)
            
            if connection_id:
                connection_id = connection_id.decode() if isinstance(connection_id, bytes) else connection_id
                logger.info(f"Found connection_id for session_id: {session_id[:8]}... → {connection_id[:8]}...")
                return connection_id
            
            logger.debug(f"No connection_id found for session_id: {session_id[:8]}...")
            return None
        except Exception as e:
            logger.error(f"Failed to get connection_id by session_id: {e}")
            return None
    
    @staticmethod
    def get_all_sessions() -> list[Dict[str, Any]]:
        """Get all active MCP sessions (for debugging/monitoring).
        
        Returns:
            List of all active session data
        """
        client = get_redis_client()
        if not client:
            return []
        
        try:
            pattern = "mcp:session:*"
            keys = client.keys(pattern)
            
            sessions = []
            for key in keys:
                value = client.get(key)
                if value:
                    sessions.append(json.loads(value))
            
            logger.debug(f"Found {len(sessions)} active MCP sessions")
            return sessions
        except Exception as e:
            logger.error(f"Failed to get all MCP sessions: {e}")
            return []
    
    @staticmethod
    def cleanup_expired_sessions() -> int:
        """Cleanup expired sessions (Redis TTL handles this automatically).
        
        This is a no-op since Redis TTL auto-expires keys.
        Kept for API completeness.
        
        Returns:
            Number of sessions cleaned up (always 0 since Redis handles this)
        """
        logger.debug("Session cleanup called (Redis TTL handles expiration automatically)")
        return 0


# Global instance
mcp_session_service = MCPSessionService()
